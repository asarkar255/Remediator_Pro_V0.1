ABAP Syntax Remediation Rules
================================

Rule 1 — Replace SELECT SINGLE * with explicit field list
---------------------------------------------------------
What to do:
- Change `SELECT SINGLE * FROM ...` to `SELECT SINGLE <field_list> FROM ...`.
- Prefer `SELECT SINGLE` over `SELECT ... UP TO 1 ROWS` when fetching one row by (full) key.

Why:
- Safer, clearer, avoids pulling unused columns and keeps result structure stable.

Examples:
Before:
  SELECT SINGLE * FROM mara WHERE matnr = lv_matnr INTO wa_mara.
After:
  SELECT SINGLE matnr meins mtart FROM mara
         INTO CORRESPONDING FIELDS OF wa_mara
         WHERE matnr = lv_matnr.  " Added By PwcYYYY-MM-DD

Before (anti-pattern):
  SELECT * FROM mara INTO wa_mara
         WHERE matnr = lv_matnr
         UP TO 1 ROWS.
  ENDSELECT.
After:
  SELECT SINGLE matnr meins mtart FROM mara
         INTO CORRESPONDING FIELDS OF wa_mara
         WHERE matnr = lv_matnr.  " Added By PwcYYYY-MM-DD

Rule 2 — Do not declare AFLE amount variables as TYPE p LENGTH 23 DECIMALS 2
----------------------------------------------------------------------------

What to do:
- For AFLE amount fields, do not use TYPE p LENGTH 23 DECIMALS 2 (invalid: P length max is 16).
- Use the DDIC amount element (e.g., DMBTR) always for AFLE amount variables.

Why:
- ABAP TYPE p length is bytes (1..16), not digits. LENGTH 23 is invalid.
- Using DDIC amount types (e.g., DMBTR) aligns with AFLE-compliant precision/scale and DB mappings.

Examples:
Before (wrong):
  DATA lv_amount TYPE p LENGTH 23 DECIMALS 2.   " WRONG: P length > 16 bytes
After (correct):
  DATA lv_amount TYPE dmbtr.                    " Added By PwcYYYY-MM-DD

Rule 3 — Do NOT add ORDER BY to SELECT SINGLE
---------------------------------------------

What to do:
- Do **not** append any `ORDER BY` clause to `SELECT SINGLE`.
- If you fetch one row **by full primary key**, use `SELECT SINGLE ... WHERE <full key>`.
- If you truly need the “top” row by a sort criterion, use:
  - an aggregate (e.g., MIN/MAX) when possible, **or**
  - `SELECT <field_list> FROM ... WHERE ... ORDER BY ... UP TO 1 ROWS.`

Why:
- `SELECT SINGLE` is intended for key-based, deterministic access; adding `ORDER BY` is semantically wrong and misleading.
- For ordered picks, use explicit `ORDER BY ... UP TO 1 ROWS` (and a field list), or an aggregate for clarity and performance.

Examples:
Before (anti-pattern):
  SELECT SINGLE * FROM mara
         WHERE matnr = lv_matnr
         ORDER BY ersda DESC
         INTO wa_mara.

After (key-based, deterministic):
  SELECT SINGLE matnr meins mtart ersda FROM mara
         INTO CORRESPONDING FIELDS OF wa_mara
         WHERE matnr = lv_matnr.  " Added By PwcYYYY-MM-DD

After (ordered top-1 by a criterion):
  SELECT matnr meins mtart ersda FROM mara
         INTO CORRESPONDING FIELDS OF wa_mara
         WHERE matnr LIKE lv_mat_pattern
         ORDER BY ersda DESC
         UP TO 1 ROWS.  " Added By PwcYYYY-MM-DD

Rule 4 — Comma-separated field lists: escape INTO/WHERE with @, ORDER BY uses commas
-----------------------------------------------------------------------------------

What to do:
- When you list fields in `SELECT` or `SELECT SINGLE` separated by commas, you must:
  - Escape host variables in the `INTO` clause with `@`.
  - Escape host variables in the `WHERE` clause with `@`.
  - Separate fields in the `ORDER BY` clause with commas.
- Do not leave `ORDER BY` fields space-separated when commas are used in the field list.

Why:
- Modern ABAP SQL syntax requires `@` escaping when host variables are used together with comma-separated field lists.
- Ensures consistency, avoids ambiguous parsing, and enforces correct Open SQL syntax.

Examples:
Before:
  SELECT *
         INTO TABLE lt_data
         WHERE matnr IN s_matnr
         ORDER BY ersda DESC.

After (wrong):
  SELECT matnr, meins, mtart FROM mara
         INTO TABLE lt_data
         WHERE matnr IN s_matnr
         ORDER BY ersda mtart DESC.  " Added By PwcYYYY-MM-DD

After (correct):
  SELECT matnr, meins, mtart FROM mara
         INTO TABLE @lt_data
         WHERE matnr IN @s_matnr
         ORDER BY ersda, mtart DESC.  " Added By PwcYYYY-MM-DD

Rule 5 — Replace SELECT on KONV table with SELECT on V_KONV CDS View
-----------------------------------------------------------------------------------
What to do:
-Replace any SELECT ... FROM konv with SELECT ... FROM v_konv.
-Adapt field names and structures as required, because the view may differ from the table.
-Always select only the fields needed.

Examples:
Before:
	SELECT * FROM konv WHERE knumv = lv_knumv INTO TABLE lt_konv.

After:
	SELECT kschl kbetr waers FROM v_konv
       INTO TABLE lt_konv
       WHERE knumv = lv_knumv.  " Added By PwcYYYY-MM-DD

Rule 6 — Replace SELECT on MARC table with SELECT on NSDM_V_MARC View
-----------------------------------------------------------------------------------
What to do:
-Change all SELECT ... FROM marc queries to select from nsdm_v_marc.
-Use an explicit field list to select only required columns.
-NSDM_V_MARC is the S/4HANA-compliant CDS view replacing table access.

Examples:
Before:
	SELECT * FROM marc WHERE matnr = lv_matnr INTO wa_marc.

After:
	SELECT matnr werks dispo FROM nsdm_v_marc
       INTO CORRESPONDING FIELDS OF wa_marc
       WHERE matnr = lv_matnr.  " Added By PwcYYYY-MM-DD

Rule 7 — Replace SELECT on MARD table with SELECT on NSDM_V_MARD View
-----------------------------------------------------------------------------------
What to do:
-Update SELECT ... FROM mard statements to use nsdm_v_mard instead.
-List necessary fields explicitly instead of using *.
-Perform adjustments for field mapping, if required.

Examples:
Before:
	SELECT * FROM mard WHERE matnr = lv_matnr INTO lt_mard.

After:
	SELECT matnr werks lgort labst FROM nsdm_v_mard
       INTO TABLE lt_mard
       WHERE matnr = lv_matnr.  " Added By PwcYYYY-MM-


Rule 8 — Do not use DESCRIBE FIELD/TABLE/LINES; use strlen( ) function instead.
-----------------------------------------------------------------------------------
What to do:
-Replace any use of DESCRIBE FIELD ... LENGTH, DESCRIBE TABLE ... LINES, or other DESCRIBE statements that attempt to determine the length of a string or the number of entries, with safer and more dynamic alternatives.
-For string length, use the standard ABAP function strlen( ) to determine the actual runtime length.
-For table lines, use the built-in function lines( ).

Examples:
Before (Detecting String Length):
  DESCRIBE FIELD lv_matnr LENGTH lv_len.
    IF lv_len = 18.
      " ... some logic ...
    ENDIF.

After (Correct Usage with strlen):
	IF strlen( lv_matnr ) = 18.
    " ... some logic ...
  ENDIF.   " Added By PwcYYYY-MM-DD

Before (Counting Internal Table Lines):
  DESCRIBE TABLE lt_matnr LINES lv_lines.
  IF lv_lines > 0.
    " ... some logic ...
  ENDIF.

After (Correct Usage with lines( )):
  IF lines( lt_matnr ) > 0.
    " ... some logic ...
  ENDIF.   " Added By PwcYYYY-MM-DD

Rule 9 — Do Not Use CONCATENATE for Simple String Assembly; Use String Templates Instead.
-----------------------------------------------------------------------------------
What to do:
-Replace any use of the CONCATENATE statement for string assembly with ABAP string templates (|...|) and string expressions.
-String templates provide clearer syntax, better readability, and reduce the risk of errors with separators.

Examples:
-Before (Using CONCATENATE Statement):
  CONCATENATE 'Material Type' wa_mat-mtype 'material code' wa_matnr-mcode ' Material Number' wa_matnr-matnr INTO lv_msg SEPARATED BY space.

-After (Correct Usage with String Template):
  lv_msg = |{ 'Material Type' && wa_mat-mtype && 'material code' && wa_matnr-mcode && ' Material Number' && wa_matnr-matnr }|.  " Added By PwcYYYY-MM-DD

Examples:
-Before (Using CONCATENATE to Join Fields with Hyphen):
  CONCATENATE wa_header-docnum wa_header-bukrs wa_header-gjahr INTO lv_key SEPARATED BY '-'.

-After (Correct Usage with String Template):
  lv_key = |{ wa_header-docnum }-{ wa_header-bukrs }-{ wa_header-gjahr }|.  " Added By PwcYYYY-MM-DD

Rule 10 — Do Not Use Classic Offset/Length Notation (var+off(len)); Use substring( ) Instead
-------------------------------------------------------------------------------------------
- What to do:
  * Replace any use of the classic ABAP offset/length substring notation (`variable+offset(length)`) with the modern `substring( )` function.
  * Always declare an intermediate CHAR variable of the correct length to store the substring result before comparisons, WHERE conditions, or logic.

- Why:
  * `var+off(len)` is considered legacy and harder to maintain.
  * `substring( )` provides explicit parameters (val, off, len), improving readability and preventing subtle bugs.

Examples:
Before:
  IF wa-matnr+2(3) NE wa-ummat+4(3).
    " ... logic ...
  ENDIF.

After:
  DATA lv_wa_matnr TYPE char3.    " Added By PwcYYYY-MM-DD
  DATA lv_wa_ummat TYPE char3.    " Added By PwcYYYY-MM-DD

  lv_wa_matnr = substring( val = wa_matnr off = 2 len = 3 ).
  lv_wa_ummat = substring( val = wa_ummat off = 4 len = 3 ).

  IF lv_wa_matnr NE lv_wa_ummat.
    " ... logic ...
  ENDIF.

Before (in WHERE clause):
  SELECT matnr ummat FROM mara INTO TABLE lt_mara WHERE ummat = ls_mara-ummat+2(5).

After:
  DATA lv_ls_ummat TYPE char5.       " Added By PwcYYYY-MM-DD
  lv_ls_ummat = substring( val = ls_mara-ummat off = 2 len = 5 ).

  SELECT matnr ummat FROM mara INTO TABLE lt_mara WHERE ummat = lv_ls_ummat.  " Added By PwcYYYY-MM-DD
  
ABAP Open SQL (S/4HANA) — Joins, Subqueries, and Staged Selects
=================================================================

Scope
-----
These rules modernize the earlier “remove subqueries” guidance for S/4HANA.
In S/4HANA (ABAP 7.4+), Open SQL supports subqueries such as IN ( SELECT … )
and EXISTS ( SELECT … ). You should **prefer a single set-based statement**
(JOIN or supported subquery) and only fall back to staged selects with
FOR ALL ENTRIES (FAE) when needed for clarity or performance.

General Principles (S/4HANA)
----------------------------
- Prefer **JOIN** when a single result set is needed and relationships are clear.
- **Subqueries (IN / EXISTS)** are supported and often more readable than FAE.
- Use staged selects + **FAE only as a fallback** (e.g., to avoid row explosion, or when
  the relationship is not conveniently joinable).
- Keep queries **set-based**. Avoid nested SELECTs inside loops.
- Use **explicit field lists** (avoid SELECT * in application code).
- Use **modern Open SQL syntax**:
  - Comma-separated field lists in SELECT and ORDER BY.
  - Escape host variables with **@**.
  - Use `INTO TABLE @it_tab` or `INTO CORRESPONDING FIELDS OF TABLE @it_tab` as needed.
  - Inline declarations (e.g., `INTO TABLE @DATA(lt_tab)`) are allowed.
- Prefer **CDS views** (released interfaces) over direct table access when available.
- Verify cardinality and indexing; measure with SQL Monitor / PlanViz when in doubt.

S/4HANA Syntax Essentials
-------------------------
- Example (field list + @-escapes + ORDER BY with commas):
  SELECT a~vbeln, a~vkorg, a~erdat
    FROM vbak AS a
    WHERE a~vkorg = @p_vkorg
    ORDER BY a~erdat DESC
    INTO TABLE @DATA(lt_vbak).

- Do **not** add ORDER BY to SELECT SINGLE. Use key access or ORDER BY … UP TO 1 ROWS instead.

Rule 11 — Replace IN (SELECT …) with JOIN or keep subquery (FAE last)
---------------------------------------------------------------------
Before (subquery):
  SELECT *
    FROM vbak
    INTO TABLE @DATA(lt_vbak)
    WHERE vkorg = @p_vkorg
      AND vbeln IN ( SELECT vbeln FROM vbap WHERE matnr = @p_matnr ).

Preferred (JOIN):
  SELECT a~vbeln, a~vkorg, a~erdat
    FROM vbak AS a
    INNER JOIN vbap AS b ON b~vbeln = a~vbeln
    WHERE a~vkorg = @p_vkorg
      AND b~matnr = @p_matnr
    INTO TABLE @DATA(lt_vbak).

Alternative (keep IN-subquery; supported and clear):
  SELECT vbeln, vkorg, erdat
    FROM vbak
    WHERE vkorg = @p_vkorg
      AND vbeln IN ( SELECT vbeln FROM vbap WHERE matnr = @p_matnr )
    INTO TABLE @lt_vbak.

Fallback (two-step + FAE; use when JOIN/subquery would multiply rows or hurt readability):
  SELECT vbeln
    FROM vbap
    WHERE matnr = @p_matnr
    INTO TABLE @DATA(lt_vbap_keys).

  SORT lt_vbap_keys BY vbeln.
  DELETE ADJACENT DUPLICATES FROM lt_vbap_keys COMPARING vbeln.

  IF lt_vbap_keys IS NOT INITIAL.
    SELECT vbeln, vkorg, erdat
      FROM vbak
      FOR ALL ENTRIES IN @lt_vbap_keys
      WHERE vkorg = @p_vkorg
        AND vbeln = @lt_vbap_keys-vbeln
      INTO TABLE @lt_vbak.
  ENDIF.

Notes:
- Use single-field key tables (e.g., TABLE OF vbap-vbeln) for memory efficiency.
- Always deduplicate the driving key table before FAE.

Rule 12 — Replace EXISTS(SELECT …) with JOIN or keep EXISTS (FAE last)
---------------------------------------------------------------------
Before (EXISTS):
  SELECT *
    FROM ekko
    INTO TABLE @DATA(lt_ekko)
    WHERE bukrs = @p_bukrs
      AND EXISTS ( SELECT * FROM ekpo
                   WHERE ekpo~ebeln = ekko~ebeln
                     AND matnr = @p_matnr ).

Preferred (EXISTS, stays as-is and is supported):
  SELECT ebeln, bukrs, bedat
    FROM ekko AS a
    WHERE bukrs = @p_bukrs
      AND EXISTS ( SELECT * FROM ekpo AS b
                   WHERE b~ebeln = a~ebeln
                     AND b~matnr = @p_matnr )
    INTO TABLE @lt_ekko.

Alternative (JOIN):
  SELECT a~ebeln, a~bukrs, a~bedat
    FROM ekko AS a
    INNER JOIN ekpo AS b ON b~ebeln = a~ebeln
    WHERE a~bukrs = @p_bukrs
      AND b~matnr = @p_matnr
    INTO TABLE @lt_ekko.

Fallback (two-step + FAE):
  SELECT ebeln
    FROM ekpo
    WHERE matnr = @p_matnr
    INTO TABLE @DATA(lt_ekpo_keys).

  SORT lt_ekpo_keys BY ebeln.
  DELETE ADJACENT DUPLICATES FROM lt_ekpo_keys COMPARING ebeln.

  IF lt_ekpo_keys IS NOT INITIAL.
    SELECT ebeln, bukrs, bedat
      FROM ekko
      FOR ALL ENTRIES IN @lt_ekpo_keys
      WHERE bukrs = @p_bukrs
        AND ebeln = @lt_ekpo_keys-ebeln
      INTO TABLE @lt_ekko.
  ENDIF.

Rule 13 — Scalar subquery in WHERE: avoid; use JOIN or staged selects
---------------------------------------------------------------------
Pattern (scalar subquery in WHERE):
  SELECT *
    FROM mara
    INTO TABLE @DATA(lt_mara)
    WHERE mtart = ( SELECT mtart FROM marc
                    WHERE matnr = mara~matnr AND werks = @p_werks ).

Preferred (JOIN; 1:1 relationship):
  SELECT a~matnr, a~mtart, b~werks
    FROM mara AS a
    INNER JOIN marc AS b
      ON b~matnr = a~matnr AND b~werks = @p_werks
    WHERE a~mtart = b~mtart
    INTO TABLE @DATA(lt_result).

Fallback (staged + FAE when JOIN would multiply rows):
  SELECT mtart
    FROM marc
    WHERE werks = @p_werks
    INTO TABLE @DATA(lt_marc_keys).

  SORT lt_marc_keys BY mtart.
  DELETE ADJACENT DUPLICATES FROM lt_marc_keys COMPARING mtart.

  IF lt_marc_keys IS NOT INITIAL.
    SELECT matnr, mtart
      FROM mara
      FOR ALL ENTRIES IN @lt_marc_keys
      WHERE mtart = @lt_marc_keys-mtart
      INTO TABLE @lt_mara.
  ENDIF.

Rule 14 — Correlated subqueries → JOIN or staged selects
-------------------------------------------------------
Before (correlated subquery):
  SELECT *
    FROM kna1
    INTO TABLE @DATA(lt_kna1)
    WHERE land1 = ( SELECT land1 FROM t001 WHERE t001~bukrs = kna1~kunnr(4) ).

Preferred (JOIN):
  SELECT a~kunnr, a~name1, b~land1
    FROM kna1 AS a
    INNER JOIN t001 AS b ON b~bukrs = a~kunnr(4)
    INTO TABLE @lt_kna1.

Fallback (staged keys + FAE):
  " Build @lt_bukrs from customers as needed (e.g., substring of kunnr)
  " Then:
  SELECT bukrs, land1
    FROM t001
    FOR ALL ENTRIES IN @lt_bukrs
    WHERE bukrs = @lt_bukrs-bukrs
    INTO TABLE @DATA(lt_t001).

Rule 15 — Guardrails for FOR ALL ENTRIES (FAE)
----------------------------------------------
- Always check: `IF it[] IS NOT INITIAL.` before FAE to avoid full-table scans.
- Deduplicate the driving table (SORT …; DELETE ADJACENT DUPLICATES …).
- The driving table should contain **only** the columns used in equality predicates.
- Prefer equality (`=`) in the FAE WHERE; ranges/IN on the right side are not supported.
- FAE skips rows where any driving field is initial—ensure keys are populated.
- For very large data sets, consider batching (PACKAGE SIZE) and check secondary indices.

Rule 16 — SELECT list subqueries are not supported → prefetch + READ TABLE or JOIN
----------------------------------------------------------------------------------
Before (pseudo-scalar in field list):
  SELECT matnr,
         ( SELECT maktg FROM makt
           WHERE makt~matnr = mara~matnr AND spras = @sy-langu ) AS maktg
    FROM mara INTO TABLE @DATA(lt_out).

Preferred (JOIN):
  SELECT a~matnr, b~maktg
    FROM mara AS a
    INNER JOIN makt AS b ON b~matnr = a~matnr AND b~spras = @sy-langu
    INTO TABLE @DATA(lt_out).

Alternative (prefetch + READ TABLE):
  SELECT matnr FROM mara INTO TABLE @DATA(lt_mara).
  IF lt_mara IS NOT INITIAL.
    SELECT matnr, maktg
      FROM makt
      WHERE spras = @sy-langu
      INTO TABLE @DATA(lt_makt).
    SORT lt_makt BY matnr.
    LOOP AT lt_mara ASSIGNING FIELD-SYMBOL(<ls_mara>).
      READ TABLE lt_makt ASSIGNING FIELD-SYMBOL(<ls_makt>)
        WITH KEY matnr = <ls_mara>-matnr BINARY SEARCH.
      IF sy-subrc = 0.
        " combine into output row as required
      ENDIF.
    ENDLOOP.
  ENDIF.

Rule 17 — Prefer JOIN when it preserves row cardinality and clarity
-------------------------------------------------------------------
- Use INNER/LEFT OUTER JOIN when:
  * join keys are indexed,
  * result cardinality is acceptable (no uncontrolled row multiplication),
  * you need columns from multiple sources in one pass.
- Use staged selects + FAE when JOIN/subquery would explode rows or obscure intent.

Performance & Correctness Checklist (S/4HANA)
---------------------------------------------
- Use field lists only; align with target structures.
- Avoid SELECT … ENDSELECT nesting; use `INTO TABLE` then process in ABAP.
- Check secondary indices and cardinality; test with realistic volumes.
- Consider aggregates and GROUP BY for “top”/distinct logic instead of client-side filtering.
- Use ORDER BY with comma-separated fields; for “top-1 by criterion”, use
  `ORDER BY … [DESC] UP TO 1 ROWS` (not SELECT SINGLE with ORDER BY).
- Prefer released CDS views and push-down calculations (calculations on DB where appropriate).

Rule 18 — Draft/active predicates when such columns exist (customer-specific)
-----------------------------------------------------------------------------
If your transparent tables/views physically contain a DRAFT flag (e.g., VBRP/VBRK in a
customer landscape), and you only want active rows, append:
  AND b~draft = space
  AND c~draft = space
Only add these predicates if the columns truly exist; never invent fields.

Rule 19 — CDS/RAP entities: use IsActiveEntity (not DRAFT)
----------------------------------------------------------
When selecting from a draft-enabled CDS/RAP entity, filter for active rows using:
  WHERE IsActiveEntity = abap_true
Do **not** add IsActiveEntity to classic transparent tables unless exposed by the CDS view.

Summary
-------
- In S/4HANA, JOINs and supported subqueries (IN, EXISTS) are first-class tools.
- Use staged selects + FAE only when JOIN/subquery is impractical.
- Keep code modern (comma-separated lists, @ host variable escapes, explicit fields).
- Validate with performance tools and prefer released CDS views where possible.
