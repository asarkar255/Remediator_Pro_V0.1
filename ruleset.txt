Rule 1 — Replace SELECT SINGLE * with explicit field list
----------------------------------------------------------------------------
Rule 2 — Do not declare AFLE amount variables as TYPE p LENGTH 23 DECIMALS 2
----------------------------------------------------------------------------
- For AFLE amount fields, do not use TYPE p LENGTH 23 DECIMALS 2 (invalid: P length max is 16).
- Use the DDIC amount element (e.g., DMBTR) always for AFLE amount variables.
Rule 3 — Do NOT add ORDER BY to SELECT SINGLE
---------------------------------------------
Rule 4 — Comma-separated field lists: escape INTO/WHERE with @, ORDER BY uses commas
-----------------------------------------------------------------------------------
- When you list fields in `SELECT` or `SELECT SINGLE` separated by commas, you must:
  - Escape host variables in the `INTO` clause with `@`.
  - Escape host variables in the `WHERE` clause with `@`.
  - Separate fields in the `ORDER BY` clause with commas.
- Do not leave `ORDER BY` fields space-separated when commas are used in the field list.

Why:
- Modern ABAP SQL syntax requires `@` escaping when host variables are used together with comma-separated field lists.
- Ensures consistency, avoids ambiguous parsing, and enforces correct Open SQL syntax.

Rule 5 — Replace SELECT on KONV table with SELECT on V_KONV CDS View
-----------------------------------------------------------------------------------
-Replace any SELECT ... FROM konv with SELECT ... FROM v_konv.
-Adapt field names and structures as required, because the view may differ from the table.
-Always select only the fields needed.

Rule 6 — Replace SELECT on MARC table with SELECT on NSDM_V_MARC View
-----------------------------------------------------------------------------------
What to do:
-Change all SELECT ... FROM marc queries to select from nsdm_v_marc.
-Use an explicit field list to select only required columns.
-NSDM_V_MARC is the S/4HANA-compliant CDS view replacing table access.

Rule 7 — Replace SELECT on MARD table with SELECT on NSDM_V_MARD View
-----------------------------------------------------------------------------------
What to do:
-Update SELECT ... FROM mard statements to use nsdm_v_mard instead.
-List necessary fields explicitly instead of using *.
-Perform adjustments for field mapping, if required.

Rule 8 — Do not use DESCRIBE FIELD/TABLE/LINES; use strlen( ) function instead.
-----------------------------------------------------------------------------------
What to do:
-Replace any use of DESCRIBE FIELD ... LENGTH, DESCRIBE TABLE ... LINES, or other DESCRIBE statements that attempt to determine the length of a string or the number of entries, with safer and more dynamic alternatives.
-For string length, use the standard ABAP function strlen( ) to determine the actual runtime length.
-For table lines, use the built-in function lines( ).

Rule 9 — Do Not Use CONCATENATE for Simple String Assembly; Use String Templates Instead.
-----------------------------------------------------------------------------------
What to do:
-Replace any use of the CONCATENATE statement for string assembly with ABAP string templates (|...|) and string expressions.
-String templates provide clearer syntax, better readability, and reduce the risk of errors with separators.

Examples:
-Before (Using CONCATENATE Statement):
  CONCATENATE 'Material Type' wa_mat-mtype 'material code' wa_matnr-mcode ' Material Number' wa_matnr-matnr INTO lv_msg SEPARATED BY space.

-After (Correct Usage with String Template):
  lv_msg = |{ 'Material Type' && wa_mat-mtype && 'material code' && wa_matnr-mcode && ' Material Number' && wa_matnr-matnr }|.  " Added By PwcYYYY-MM-DD

Examples:
-Before (Using CONCATENATE to Join Fields with Hyphen):
  CONCATENATE wa_header-docnum wa_header-bukrs wa_header-gjahr INTO lv_key SEPARATED BY '-'.

-After (Correct Usage with String Template):
  lv_key = |{ wa_header-docnum }-{ wa_header-bukrs }-{ wa_header-gjahr }|.  " Added By PwcYYYY-MM-DD

Rule 10 — Do Not Use Classic Offset/Length Notation (var+off(len)); Use substring( ) Instead
-------------------------------------------------------------------------------------------
- What to do:
  * Replace any use of the classic ABAP offset/length substring notation (`variable+offset(length)`) with the modern `substring( )` function.
  * Always declare an intermediate CHAR variable of the correct length to store the substring result before comparisons, WHERE conditions, or logic.

- Why:
  * `var+off(len)` is considered legacy and harder to maintain.
  * `substring( )` provides explicit parameters (val, off, len), improving readability and preventing subtle bugs.

Examples:
Before:
  IF wa-matnr+2(3) NE wa-ummat+4(3).
    " ... logic ...
  ENDIF.

After:
  DATA lv_wa_matnr TYPE char3.    " Added By PwcYYYY-MM-DD
  DATA lv_wa_ummat TYPE char3.    " Added By PwcYYYY-MM-DD

  lv_wa_matnr = substring( val = wa_matnr off = 2 len = 3 ).
  lv_wa_ummat = substring( val = wa_ummat off = 4 len = 3 ).

  IF lv_wa_matnr NE lv_wa_ummat.
    " ... logic ...
  ENDIF.

Before (in WHERE clause):
  SELECT matnr ummat FROM mara INTO TABLE lt_mara WHERE ummat = ls_mara-ummat+2(5).

After:
  DATA lv_ls_ummat TYPE char5.       " Added By PwcYYYY-MM-DD
  lv_ls_ummat = substring( val = ls_mara-ummat off = 2 len = 5 ).

  SELECT matnr ummat FROM mara INTO TABLE lt_mara WHERE ummat = lv_ls_ummat.  " Added By PwcYYYY-MM-DD
  
Rule 11 — Replace IN (SELECT …) with JOIN or keep subquery (FAE last)
---------------------------------------------------------------------
Before (subquery):
  SELECT *
    FROM vbak
    INTO TABLE @DATA(lt_vbak)
    WHERE vkorg = @p_vkorg
      AND vbeln IN ( SELECT vbeln FROM vbap WHERE matnr = @p_matnr ).

Preferred (JOIN):
  SELECT a~vbeln, a~vkorg, a~erdat
    FROM vbak AS a
    INNER JOIN vbap AS b ON b~vbeln = a~vbeln
    WHERE a~vkorg = @p_vkorg
      AND b~matnr = @p_matnr
    INTO TABLE @DATA(lt_vbak).

Alternative (keep IN-subquery; supported and clear):
  SELECT vbeln, vkorg, erdat
    FROM vbak
    WHERE vkorg = @p_vkorg
      AND vbeln IN ( SELECT vbeln FROM vbap WHERE matnr = @p_matnr )
    INTO TABLE @lt_vbak.

Fallback (two-step + FAE; use when JOIN/subquery would multiply rows or hurt readability):
  SELECT vbeln
    FROM vbap
    WHERE matnr = @p_matnr
    INTO TABLE @DATA(lt_vbap_keys).

  SORT lt_vbap_keys BY vbeln.
  DELETE ADJACENT DUPLICATES FROM lt_vbap_keys COMPARING vbeln.

  IF lt_vbap_keys IS NOT INITIAL.
    SELECT vbeln, vkorg, erdat
      FROM vbak
      FOR ALL ENTRIES IN @lt_vbap_keys
      WHERE vkorg = @p_vkorg
        AND vbeln = @lt_vbap_keys-vbeln
      INTO TABLE @lt_vbak.
  ENDIF.

Notes:
- Use single-field key tables (e.g., TABLE OF vbap-vbeln) for memory efficiency.
- Always deduplicate the driving key table before FAE.

Rule 12 — Scalar subquery in WHERE: avoid; use JOIN or staged selects
---------------------------------------------------------------------
Pattern (scalar subquery in WHERE):
  SELECT *
    FROM mara
    INTO TABLE @DATA(lt_mara)
    WHERE mtart = ( SELECT mtart FROM marc
                    WHERE matnr = mara~matnr AND werks = @p_werks ).

Preferred (JOIN; 1:1 relationship):
  SELECT a~matnr, a~mtart, b~werks
    FROM mara AS a
    INNER JOIN marc AS b
      ON b~matnr = a~matnr AND b~werks = @p_werks
    WHERE a~mtart = b~mtart
    INTO TABLE @DATA(lt_result).

Fallback (staged + FAE when JOIN would multiply rows):
  SELECT mtart
    FROM marc
    WHERE werks = @p_werks
    INTO TABLE @DATA(lt_marc_keys).

  SORT lt_marc_keys BY mtart.
  DELETE ADJACENT DUPLICATES FROM lt_marc_keys COMPARING mtart.

  IF lt_marc_keys IS NOT INITIAL.
    SELECT matnr, mtart
      FROM mara
      FOR ALL ENTRIES IN @lt_marc_keys
      WHERE mtart = @lt_marc_keys-mtart
      INTO TABLE @lt_mara.
  ENDIF.

Rule 13 — Correlated subqueries → JOIN or staged selects
-------------------------------------------------------
Before (correlated subquery):
  SELECT *
    FROM kna1
    INTO TABLE @DATA(lt_kna1)
    WHERE land1 = ( SELECT land1 FROM t001 WHERE t001~bukrs = kna1~kunnr(4) ).

Preferred (JOIN):
  SELECT a~kunnr, a~name1, b~land1
    FROM kna1 AS a
    INNER JOIN t001 AS b ON b~bukrs = a~kunnr(4)
    INTO TABLE @lt_kna1.

Fallback (staged keys + FAE):
  " Build @lt_bukrs from customers as needed (e.g., substring of kunnr)
  " Then:
  SELECT bukrs, land1
    FROM t001
    FOR ALL ENTRIES IN @lt_bukrs
    WHERE bukrs = @lt_bukrs-bukrs
    INTO TABLE @DATA(lt_t001).

Rule 14 — Guardrails for FOR ALL ENTRIES (FAE)
----------------------------------------------
- Always check: `IF it[] IS NOT INITIAL.` before FAE to avoid full-table scans.
- Deduplicate the driving table (SORT …; DELETE ADJACENT DUPLICATES …).
- The driving table should contain **only** the columns used in equality predicates.
- Prefer equality (`=`) in the FAE WHERE; ranges/IN on the right side are not supported.
- FAE skips rows where any driving field is initial—ensure keys are populated.
- For very large data sets, consider batching (PACKAGE SIZE) and check secondary indices.

Rule 15 — Draft/active predicates when such columns exist (customer-specific)
-----------------------------------------------------------------------------
When llm prompt ask to add draft = space always add it for the table mentioned(Mandatory)
If your transparent tables/views physically contain a DRAFT flag (e.g., VBRP/VBRK in a
customer landscape), and you only want active rows, append:
  AND b~draft = space
  AND c~draft = space

